"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const effects_1 = require("./effects");
const param_1 = require("./param");
function optional(flag, createComponent) {
    let component;
    const updater = param_1.stream(flag)(isVisible => {
        if (isVisible) {
            component = createComponent();
            return () => {
                if (component) {
                    component.dispose();
                    component = null;
                }
            };
        }
    });
    return {
        update: () => {
            updater.update();
            component && component.update();
        },
        dispose: updater.dispose
    };
}
exports.optional = optional;
function list(items, key, createComponent) {
    const children = new Map(), values = new Map();
    const update = param_1.changes(items)(items => {
        const keys = new Set();
        items.forEach((v, i) => {
            const k = key(v, i);
            keys.add(k);
            values.set(k, v);
            if (!children.has(k)) {
                children.set(k, createComponent(() => {
                    return values.get(k);
                }));
            }
        });
        Array.from(children.keys()).forEach(k => {
            if (!keys.has(k)) {
                children.get(k).dispose();
                children.delete(k);
                values.delete(k);
            }
        });
    });
    return {
        dispose: () => children.forEach((component) => component.dispose()),
        update: effects_1.composeEffects(update, () => {
            children.forEach((component) => component.update());
        }),
    };
}
exports.list = list;
function group(...components) {
    return {
        update: effects_1.composeEffects(...components.map(c => c.update)),
        dispose: effects_1.composeEffects(...components.map(c => c.dispose)),
    };
}
exports.group = group;
function cache(...input) {
    const values = [], params = input.map((v, i) => param_1.isValue(v) ? v : (() => values[i])), update = effects_1.composeEffects(...input.map((v, i) => param_1.changes(v)(v => values[i] = v)));
    return (mapping) => {
        const child = mapping(...params);
        return {
            update: effects_1.composeEffects(update, child.update),
            dispose: child.dispose,
        };
    };
}
exports.cache = cache;
/**
 * Recreate component on parameters change
 */
function cmap(...input) {
    if (input.every(param_1.isValue)) {
        return (create) => {
            return create(...input);
        };
    }
    else {
        return (create) => {
            let values = input.map(param_1.unwrap);
            let component = create(...values);
            return {
                update: () => {
                    const newValues = input.map(param_1.unwrap);
                    if (newValues.every((v, i) => v === values[i])) {
                        component.update();
                    }
                    else {
                        component.dispose();
                        values = newValues;
                        component = create(...values);
                    }
                },
                dispose: () => {
                    component.dispose();
                }
            };
        };
    }
}
exports.cmap = cmap;
//# sourceMappingURL=component.js.map