import { Effect } from "./effects";
import { Component } from "./component";
/**
 * Constant parameter or parameter that can be changed from time to time
 */
export declare type Param<T> = (() => T) | T;
export declare type Unwrap<T> = T extends () => infer R ? R : T;
export declare type UnwrapList<T extends Param<any>[]> = T extends [any, any, any, any, any, any] ? [Unwrap<T[0]>, Unwrap<T[1]>, Unwrap<T[2]>, Unwrap<T[3]>, Unwrap<T[4]>, Unwrap<T[5]>] : T extends [any, any, any, any, any] ? [Unwrap<T[0]>, Unwrap<T[1]>, Unwrap<T[2]>, Unwrap<T[3]>, Unwrap<T[4]>] : T extends [any, any, any, any] ? [Unwrap<T[0]>, Unwrap<T[1]>, Unwrap<T[2]>, Unwrap<T[3]>] : T extends [any, any, any] ? [Unwrap<T[0]>, Unwrap<T[1]>, Unwrap<T[2]>] : T extends [any, any] ? [Unwrap<T[0]>, Unwrap<T[1]>] : T extends [any] ? [Unwrap<T[0]>] : [];
/**
 * Is constant parameter
 */
export declare function isValue<T>(v: Param<T>): v is T;
/**
 * Is variable parameter
 */
export declare function isMapping<T>(v: Param<T>): v is () => T;
/**
 * Returns the current value of the parameter
 */
export declare function unwrap<T>(v: Param<T>): T;
/**
 * Map set of parameters to a new parameter
 */
export declare function map<P extends Param<any>[]>(...input: P): <T>(mapping: (...params: UnwrapList<P>) => T) => Param<T>;
/**
 * Pass changes of parameters to a function.
 * @returns Updater function that looks for parameter changes.
 */
export declare function changes<P extends Param<any>[]>(...input: P): (mapping: (...params: UnwrapList<P>) => void | Effect) => Effect;
/**
 * The same as `changes`, but the effect can have some disposable data.
 * See also ReactJS `useEffect` hook.
 */
export declare function stream<P extends Param<any>[]>(...input: P): (mapping: (...params: UnwrapList<P>) => void | Effect) => Component;
declare type ParamMap<T> = {
    [key in keyof T]?: Param<T[key]>;
};
/**
 * Returns a function that writes parametrs map to the coresponding fields of the target
 */
export declare function write<T>(target: T, props: ParamMap<T>): Effect;
export {};
