"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const effects_1 = require("./effects");
/**
 * Is constant parameter
 */
function isValue(v) {
    return !(v instanceof Function);
}
exports.isValue = isValue;
/**
 * Is variable parameter
 */
function isMapping(v) {
    return (v instanceof Function);
}
exports.isMapping = isMapping;
/**
 * Returns the current value of the parameter
 */
function unwrap(v) {
    return isValue(v) ? v : v();
}
exports.unwrap = unwrap;
/**
 * Map set of parameters to a new parameter
 */
function map(...input) {
    if (input.every(v => isValue(v))) {
        return (mapping) => {
            return mapping(...input);
        };
    }
    else {
        return (mapping) => {
            return () => mapping(...input.map(unwrap));
        };
    }
}
exports.map = map;
/**
 * Pass changes of parameters to a function.
 * @returns Updater function that looks for parameter changes.
 */
function changes(...input) {
    if (input.every(v => isValue(v))) {
        return (mapping) => {
            mapping(...input);
            return effects_1.noop;
        };
    }
    else {
        return (mapping) => {
            let values = input.map(unwrap);
            mapping(...values);
            return () => {
                const newValues = input.map(unwrap);
                if (newValues.some((v, i) => v !== values[i])) {
                    values = newValues;
                    mapping(...values);
                }
            };
        };
    }
}
exports.changes = changes;
/**
 * The same as `changes`, but the effect can have some disposable data.
 * See also ReactJS `useEffect` hook.
 */
function stream(...input) {
    if (input.every(v => isValue(v))) {
        return (mapping) => {
            const dispose = mapping(...input);
            return {
                update: effects_1.noop,
                dispose: dispose || effects_1.noop
            };
        };
    }
    else {
        return (mapping) => {
            let values = input.map(unwrap), dispose = mapping(...values);
            return {
                update() {
                    const newValues = input.map(unwrap);
                    if (newValues.some((v, i) => v !== values[i])) {
                        dispose && dispose();
                        values = newValues;
                        dispose = mapping(...values);
                    }
                },
                dispose() {
                    dispose && dispose();
                }
            };
        };
    }
}
exports.stream = stream;
/**
 * Returns a function that writes parametrs map to the coresponding fields of the target
 */
function write(target, props) {
    const updaters = [];
    for (let i in props) {
        ((i) => {
            updaters.push(changes(props[i])((value) => {
                target[i] = value;
            }));
        })(i);
    }
    return effects_1.composeEffects(...updaters);
}
exports.write = write;
//# sourceMappingURL=param.js.map